// @bun
import*as Z from"@babel/parser";import _ from"@babel/traverse";var{file:w,write:A}=globalThis.Bun;import I from"fast-glob";class T{files=[];classes=new Set;importMap=new Map;resolvedImports=new Map;StateValues=new Map;constructor({include:j=[]}={}){j.forEach((q)=>this.classes.add(q))}async load(j){let q=await I(j);for(let D of q){let z=await w(D).text(),R=Z.parse(z,{sourceType:"module",plugins:["jsx","typescript","decorators"]});_(R,{AssignmentExpression:(F)=>{let H=F.node.left;if(H.type==="MemberExpression"){if(K(H.property)==="value"){let O=K(H.object);if(O){let M=F.scope.getBinding(O);if(M){let Q=Y(M.path.node);if(Q&&K(Q)==="State")U.call(this,F.node.right,O)}}}}},CallExpression:(F)=>{let H=F.node;if(H.type==="CallExpression"){let{arguments:O,callee:M}=H,Q=K(M);if(Q&&["add","remove","toggle"].includes(Q)){if(M.type==="MemberExpression"){let V=K(M.object);if(V){let W=F.scope.getBinding(V);if(W){let X=Y(W.path.node);if(X){if(K(X)==="$")O.forEach((J)=>{L.call(this,J,F)})}}}}}}},JSXAttribute:(F)=>{if(F.node.name.name==="class"){let H=F.node.value;if(H&&H.type==="StringLiteral")L.call(this,H,F);else if(H&&H.type==="JSXExpressionContainer")L.call(this,H.expression,F)}}})}return this}setState(j,q){if(!this.StateValues.has(j))this.StateValues.set(j,new Set([q]));else this.StateValues.get(j).add(q)}async export(j,q="shaker"){let D=JSON.stringify([...this.classes.values()].filter((z)=>z));await A(j+"/"+q+".json",D)}get shaker(){return[...this.classes.values()]}}function U(j,q){switch(j.type){case"StringLiteral":this.setState(q,j.value);break;case"MemberExpression":U.call(this,j.property,q);break;case"Identifier":this.setState(q,j.name);break;case"ArrayExpression":j.elements.forEach((D)=>{if(D)U.call(this,D,q)});break;default:break}}async function L(j,q){switch(j.type){case"StringLiteral":j.value.split(/\s+/).forEach((z)=>this.classes.add(z));break;case"CallExpression":j.arguments.forEach(async(z)=>{await L.call(this,z,q)});break;case"ArrayExpression":j.elements.forEach(async(z)=>{if(z)await L.call(this,z,q)});break;case"MemberExpression":if(j.property.type==="Identifier")this.classes.add(j.property.name);break;case"ConditionalExpression":await L.call(this,j.consequent,q),await L.call(this,j.alternate,q);break;case"Identifier":let D=q.scope.getBinding(j.name);if(D&&D.path.node.type==="VariableDeclarator"){let z=this.StateValues.get(j.name);if(z)z.forEach((R)=>R.split(/\s+/).forEach((F)=>this.classes.add(F)));await B.call(this,D.path.node,q)}break;default:break}}async function B(j,q){switch(j.type){case"VariableDeclarator":if(j.id.type==="Identifier"){let D=j.init;if(D&&D.type==="CallExpression")D.arguments.forEach(async(z)=>{await L.call(this,z,q)})}break;default:break}}function K(j){switch(j.type){case"Identifier":return j.name;case"ObjectPattern":return"";case"CallExpression":return K(j.callee);case"MemberExpression":return K(j.property);default:break}}function Y(j){switch(j.type){case"VariableDeclarator":return j.init;default:break}}export{T as SweetShaker};
